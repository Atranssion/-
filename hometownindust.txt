现在是10月7号的12点30分。
终于在这台办公电脑上，用git的命令行工具完成了一次符合目的的push。

这次的结论有：
1，git是不支持中文文件名的。本次push 99%的时间花费在了如何清除“Changes not staged for commit:”下面的那条乱码记录。后来发现解决之道是把这个（已删除的）文件（名）添加进git库即可，这样git的机制就可以明白到底“删除它”这一事件该如何被记录下来。报错信息也就不存在了。


12:42
刚刚的commit触发了crlf与lf的转换问题。

我从很早就知道github的存在。也尝试过去了解git的机制，但一直都触皮而止。今天算是终于开了个头。

Git到目前为止给我的印象还是通过“两套仓库”的设计，来尝试解决版本控制中的时间戳问题。如其官方网站上介绍的那样

---------
时刻保持数据完整性

在保存到 Git 之前，所有数据都要进行内容的校验和（checksum）计算，并将此结果作为数据的唯一标识和索引。换句话说，不可能在你修改了文件或目录之后，Git 一无所知。这项特性作为 Git 的设计哲学，建在整体架构的最底层。所以如果文件在传输时变得不完整，或者磁盘损坏导致文件数据缺失，Git 都能立即察觉。

Git 使用 SHA-1 算法计算数据的校验和，通过对文件的内容或目录的结构计算出一个 SHA-1 哈希值，作为指纹字符串。该字串由 40 个十六进制字符（0-9 及 a-f）组成，看起来就像是：

24b9da6552252987aa493b52f8696cd6d3b00373

Git 的工作完全依赖于这类指纹字串，所以你会经常看到这样的哈希值。实际上，所有保存在 Git 数据库中的东西都是用此哈希值来作索引的，而不是靠文件名。
--------------

我觉得 Git 使用中非常重要的一点是关于远程仓库的使用，尽管它的核心概念可能在于branch和fork。

对于我而言，直觉上，本地仓库是我的branch，远程仓库是我的备份。但Git本质上不是这样，它多了一层，有个staging area,用来当暂存。这一点需要好好体会。

我还要从在github建立一个仓库时它默认的三种提示出发，认真理清git的机制。

唉，windows对汉字引号的处理真的是从win7开始就变成屎了？“”
